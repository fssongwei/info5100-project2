<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <title>Project 2</title>

    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
      }

      h2 {
        font-family: "Bebas Neue", cursive;
        font-size: 30px;
        text-align: center;
      }

      /* .city {
        pointer-events: none;
      } */
    </style>
  </head>
  <body>
    <svg id="plot" width="1500" height="1000"></svg>

    <script>
      (async () => {
        const svg = d3.select("svg#plot");
        const viewport = svg.append("g");
        const width = svg.attr("width");
        const height = svg.attr("height");

        const statesGeoData = await d3.json("./us.json", d3.autoType);
        const states = topojson.feature(
          statesGeoData,
          statesGeoData.objects.states
        );
        const citiesGeoData = await d3.json("./cities.json", d3.autoType);
        const cities = topojson.feature(
          citiesGeoData,
          citiesGeoData.objects.us_cities
        );

        const projection = d3.geoAlbersUsa().fitSize([width, height], states);
        const path = d3.geoPath().projection(projection);

        const crimeData = await d3.csv("./crime.csv", d3.autoType);

        const totalCrimesExtents = d3.extent(crimeData, (d) => d.cases);
        const totalCrimesInStates = new Map();
        const crimesRecord = new Map();
        for (let { state, city, cases, solve, rate } of crimeData) {
          let nCase = (totalCrimesInStates.get(state) || 0) + cases;
          totalCrimesInStates.set(state, nCase);
          crimesRecord.set(`${state}/${city}`, { cases, solve, rate });
        }

        const stateColorScale = d3
          .scaleLinear()
          .domain(totalCrimesExtents)
          .range([d3.rgb("#eee"), d3.rgb("#999")]);

        viewport
          .selectAll("states")
          .data(states.features)
          .join("path")
          .attr("class", "states")
          .attr("d", path)
          .style("fill", (d) =>
            stateColorScale(totalCrimesInStates.get(d.properties.NAME))
          );

        let radiusScale = d3
          .scaleLinear()
          .domain(totalCrimesExtents)
          .range([3, 10]);

        viewport
          .selectAll("cities")
          .data(cities.features)
          .join("circle")
          .attr("class", "city")
          .attr("cx", (d) => projection(d.geometry.coordinates)[0])
          .attr("cy", (d) => projection(d.geometry.coordinates)[1])
          .attr("r", (d) => {
            let crimeRecord = crimesRecord.get(
              `${d.properties.state}/${d.properties.name}`
            );
            if (!crimeRecord) return 0;
            return radiusScale(crimeRecord.cases);
          })
          .attr("visibility", "hidden")
          .attr("fill", (d) => {
            let crimeRecord = crimesRecord.get(
              `${d.properties.state}/${d.properties.name}`
            );
            if (!crimeRecord) {
              return "transparent";
            }
            if (crimeRecord.rate > 0.7) return "green";
            return "red";
          });

        drawLegend(stateColorScale, totalCrimesExtents, svg);

        const zoom = d3
          .zoom()
          .scaleExtent([1, 10])
          .on("zoom", ({ transform }) => mapZoomed(transform, viewport));

        svg.call(zoom);

        viewport
          .selectAll(".states")
          .on("click", (event, d) =>
            clickState(event, d, width, height, svg, path, zoom)
          );

        let tooltipWidth = 120;
        let tooltipHeight = 50;
        const tooltip = viewport
          .append("g")
          .attr("class", "tooltip")
          .attr("visibility", "hidden");
        tooltip
          .append("rect")
          .attr("fill", "steelblue")
          .attr("opacity", 0.8)
          .attr("width", tooltipWidth)
          .attr("height", tooltipHeight);
        let cityLabel = tooltip.append("text").attr("x", 2).attr("y", 2);
        let casesLabel = tooltip.append("text").attr("x", 2).attr("y", 12);
        let solveLabel = tooltip.append("text").attr("x", 2).attr("y", 22);
        let rateLabel = tooltip.append("text").attr("x", 2).attr("y", 32);

        tooltip
          .selectAll("text")
          .attr("fill", "white")
          .attr("alignment-baseline", "hanging")
          .style("font-size", "9px");
        viewport.selectAll(".city").on("mouseenter", mouseEntersPlot);
        viewport.selectAll(".city").on("mouseout", mouseLeavesPlot);

        function mouseEntersPlot() {
          tooltip.style("visibility", "visible");

          const city = d3.select(this);
          const data = city.datum();
          const coordinates = data.geometry.coordinates;
          const properties = data.properties;

          let crimeRecord = crimesRecord.get(
            `${properties.state}/${properties.name}`
          );
          if (!crimeRecord) return;

          let pos = projection(coordinates);
          let xPos = pos[0] + 10;
          let yPos = pos[1];

          tooltip.attr("transform", `translate(${xPos},${yPos})`);
          cityLabel.text("City: " + properties.name);
          casesLabel.text("# of cases: " + crimeRecord.cases);
          solveLabel.text("# of solved cases: " + crimeRecord.solve);
          rateLabel.text(
            "Crime solve rate: " + Math.round(crimeRecord.rate * 100) + "%"
          );
        }

        function mouseLeavesPlot() {
          tooltip.style("visibility", "hidden");
        }
      })();

      const mapZoomed = (transform, viewport) => {
        viewport.attr("transform", transform.toString());
        viewport
          .selectAll(".city")
          .attr("visibility", transform.k > 1.2 ? "visible" : "hidden");
      };

      const clickState = (event, d, mapWidth, mapHeight, svg, path, zoom) => {
        let bounds = path.bounds(d.geometry);
        let dx = bounds[1][0] - bounds[0][0];
        let dy = bounds[1][1] - bounds[0][1];
        let x = bounds[0][0] + bounds[1][0];
        let y = bounds[0][1] + bounds[1][1];

        let scale = Math.max(
          1,
          Math.min(5, 0.5 / Math.max(dx / mapWidth, dy / mapHeight))
        );
        let translate = [mapWidth / 2 - x * scale, mapHeight / 2 - y * scale];

        let newTransform = d3.zoomIdentity
          .translate(translate[0], translate[1])
          .scale(scale);
        svg.transition().duration(1000).call(zoom.transform, newTransform);
      };

      const drawLegend = (scale, domain, svg) => {
        let legend = svg.append("g");
        let gap = Math.ceil((domain[1] - domain[0]) / 5);
        let barWidth = 50;
        let barHeight = 10;
        for (let i = domain[0]; i <= domain[1]; i += gap) {
          let rectangle = legend
            .append("rect")
            .attr("x", 0 + (i / gap) * barWidth)
            .attr("y", 0)
            .attr("width", barWidth)
            .attr("height", barHeight)
            .style("fill", () => scale(i));
        }
        legend.attr("transform", "translate(0,950)");
      };
    </script>
  </body>
</html>
